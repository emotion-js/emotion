{"version":3,"file":"emotion-jest.modern.js","sources":["../src/replace-class-names.js","../src/utils.js","../src/create-serializer.js","../src/matchers.js"],"sourcesContent":["// @flow\nfunction defaultClassNameReplacer(className, index) {\n  return `emotion-${index}`\n}\n\nconst componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/\n\nexport const replaceClassNames = (\n  classNames: Array<string>,\n  styles: string,\n  code: string,\n  keys: Array<string>,\n  classNameReplacer: (\n    className: string,\n    index: number\n  ) => string = defaultClassNameReplacer\n) => {\n  let index = 0\n  let keyPattern = new RegExp(`^(${keys.join('|')})-`)\n\n  return classNames.reduce((acc, className) => {\n    if (\n      keyPattern.test(className) ||\n      componentSelectorClassNamePattern.test(className)\n    ) {\n      const escapedRegex = new RegExp(\n        className.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&'),\n        'g'\n      )\n      return acc.replace(escapedRegex, classNameReplacer(className, index++))\n    }\n    return acc\n  }, `${styles}${styles ? '\\n\\n' : ''}${code}`)\n}\n","// @flow\n\nconst isBrowser = typeof document !== 'undefined'\n\nfunction last(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined\n}\n\nexport function flatMap<T, S>(arr: T[], iteratee: (arg: T) => S[] | S): S[] {\n  return [].concat(...arr.map(iteratee))\n}\n\nexport function findLast<T>(arr: T[], predicate: (T) => boolean) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i]\n    }\n  }\n}\n\nexport function findIndexFrom<T>(\n  arr: T[],\n  fromIndex: number,\n  predicate: (T) => boolean\n) {\n  for (let i = fromIndex; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nfunction getClassNames(selectors: any, classes?: string) {\n  return classes ? selectors.concat(classes.split(' ')) : selectors\n}\n\nfunction getClassNamesFromTestRenderer(selectors, { props = {} }) {\n  return getClassNames(selectors, props.className || props.class)\n}\n\nfunction shouldDive(node) {\n  return typeof node.dive === 'function' && typeof node.type() !== 'string'\n}\n\nfunction isTagWithClassName(node) {\n  return node.prop('className') && typeof node.type() === 'string'\n}\n\nfunction findNodeWithClassName(node) {\n  // Find the first node with a className prop\n  const found = node.findWhere(isTagWithClassName)\n  return found.length ? found.first() : null\n}\n\nfunction getClassNameProp(node) {\n  return (node && node.prop('className')) || ''\n}\n\nfunction getClassNamesFromEnzyme(selectors, node) {\n  // We need to dive in to get the className if we have a styled element from a shallow render\n  const isShallow = shouldDive(node)\n  const nodeWithClassName = findNodeWithClassName(\n    isShallow ? node.dive() : node\n  )\n  return getClassNames(selectors, getClassNameProp(nodeWithClassName))\n}\n\nfunction getClassNamesFromCheerio(selectors, node) {\n  const classes = node.attr('class')\n  return getClassNames(selectors, classes)\n}\n\nfunction getClassNamesFromDOMElement(selectors, node: any) {\n  return getClassNames(selectors, node.getAttribute('class'))\n}\n\nexport function isReactElement(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.test.json') ||\n    val.$$typeof === Symbol.for('react.element')\n  )\n}\n\nexport function isEmotionCssPropElementType(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.element') &&\n    val.type.$$typeof === Symbol.for('react.forward_ref') &&\n    val.type.displayName === 'EmotionCssPropInternal'\n  )\n}\n\nexport function isEmotionCssPropEnzymeElement(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.test.json') &&\n    val.type === 'EmotionCssPropInternal'\n  )\n}\nconst domElementPattern = /^((HTML|SVG)\\w*)?Element$/\n\nexport function isDOMElement(val: any): boolean {\n  return (\n    val.nodeType === 1 &&\n    val.constructor &&\n    val.constructor.name &&\n    domElementPattern.test(val.constructor.name)\n  )\n}\n\nfunction isEnzymeElement(val: any): boolean {\n  return typeof val.findWhere === 'function'\n}\n\nfunction isCheerioElement(val: any): boolean {\n  return val.cheerio === '[cheerio object]'\n}\n\nexport function getClassNamesFromNodes(nodes: Array<any>) {\n  return nodes.reduce((selectors, node) => {\n    if (isEnzymeElement(node)) {\n      return getClassNamesFromEnzyme(selectors, node)\n    } else if (isCheerioElement(node)) {\n      return getClassNamesFromCheerio(selectors, node)\n    } else if (isReactElement(node)) {\n      return getClassNamesFromTestRenderer(selectors, node)\n    }\n    return getClassNamesFromDOMElement(selectors, node)\n  }, [])\n}\n\nconst keyframesPattern = /^@keyframes\\s+(animation-[^{\\s]+)+/\n\nconst removeCommentPattern = /\\/\\*[\\s\\S]*?\\*\\//g\n\nconst getElementRules = (element: HTMLStyleElement): string[] => {\n  const nonSpeedyRule = element.textContent\n  if (nonSpeedyRule) {\n    return [nonSpeedyRule]\n  }\n  if (!element.sheet) {\n    return []\n  }\n  // $FlowFixMe - flow doesn't know about `cssRules` property\n  return [].slice.call(element.sheet.cssRules).map((cssRule) => cssRule.cssText)\n}\n\nconst getKeyframesMap = (rules) =>\n  rules.reduce((keyframes, rule) => {\n    const match = rule.match(keyframesPattern)\n    if (match !== null) {\n      const name = match[1]\n      if (keyframes[name] === undefined) {\n        keyframes[name] = ''\n      }\n      keyframes[name] += rule\n    }\n    return keyframes\n  }, {})\n\nexport function getStylesFromClassNames(\n  classNames: Array<string>,\n  elements: Array<HTMLStyleElement>\n): string {\n  if (!classNames.length) {\n    return ''\n  }\n  const keys = getKeys(elements)\n  if (!keys.length) {\n    return ''\n  }\n\n  const targetClassName = classNames.find((className) =>\n    /^e[a-z0-9]+$/.test(className)\n  )\n  const keyPattern = `(${keys.join('|')})-`\n  const classNamesRegExp = new RegExp(\n    targetClassName ? `^(${keyPattern}|${targetClassName})` : `^${keyPattern}`\n  )\n  const filteredClassNames = classNames.filter((className) =>\n    classNamesRegExp.test(className)\n  )\n\n  if (!filteredClassNames.length) {\n    return ''\n  }\n  const selectorPattern = new RegExp(\n    '\\\\.(?:' + filteredClassNames.map((cls) => `(${cls})`).join('|') + ')'\n  )\n\n  const rules = flatMap(elements, getElementRules)\n\n  let styles = rules\n    .map((rule: string) => {\n      const match = rule.match(selectorPattern)\n      if (!match) {\n        return null\n      }\n      // `selectorPattern` represents all emotion-generated class names\n      // each possible class name is wrapped in a capturing group\n      // and those groups appear in the same order as they appear in the DOM within class attributes\n      // because we've gathered them from the DOM in such order\n      // given that information we can sort matched rules based on the capturing group that has been matched\n      // to end up with styles in a stable order\n      const matchedCapturingGroupIndex = findIndexFrom(match, 1, Boolean)\n      return [rule, matchedCapturingGroupIndex]\n    })\n    .filter(Boolean)\n    .sort(\n      ([ruleA, classNameIndexA], [ruleB, classNameIndexB]) =>\n        classNameIndexA - classNameIndexB\n    )\n    .map(([rule]) => rule)\n    .join('')\n\n  const keyframesMap = getKeyframesMap(rules)\n  const keyframeNameKeys = Object.keys(keyframesMap)\n  let keyframesStyles = ''\n\n  if (keyframeNameKeys.length) {\n    const keyframesNamePattern = new RegExp(keyframeNameKeys.join('|'), 'g')\n    const keyframesNameCache = {}\n    let index = 0\n\n    styles = styles.replace(keyframesNamePattern, (name) => {\n      if (keyframesNameCache[name] === undefined) {\n        keyframesNameCache[name] = `animation-${index++}`\n        keyframesStyles += keyframesMap[name]\n      }\n      return keyframesNameCache[name]\n    })\n\n    keyframesStyles = keyframesStyles.replace(keyframesNamePattern, (value) => {\n      return keyframesNameCache[value]\n    })\n  }\n\n  return (keyframesStyles + styles).replace(removeCommentPattern, '')\n}\n\nexport function getStyleElements(): Array<HTMLStyleElement> {\n  if (!isBrowser) {\n    throw new Error(\n      'jest-emotion requires jsdom. See https://jestjs.io/docs/en/configuration#testenvironment-string for more information.'\n    )\n  }\n  const elements = Array.from(document.querySelectorAll('style[data-emotion]'))\n  // $FlowFixMe\n  return elements\n}\n\nconst unique = (arr) => Array.from(new Set(arr))\n\nexport function getKeys(elements: Array<HTMLStyleElement>) {\n  const keys = unique(\n    elements.map(\n      (element) =>\n        // $FlowFixMe we know it exists since we query for elements with this attribute\n        (element.getAttribute('data-emotion'): string)\n    )\n  ).filter(Boolean)\n  return keys\n}\n\nexport function hasClassNames(\n  classNames: Array<string>,\n  selectors: Array<string>,\n  target?: string | RegExp\n): boolean {\n  // selectors is the classNames of specific css rule\n  return selectors.some((selector) => {\n    // if no target, use className of the specific css rule and try to find it\n    // in the list of received node classNames to make sure this css rule\n    // applied for root element\n    if (!target) {\n      const lastCls = last(selector.split(' '))\n      if (!lastCls) {\n        return false\n      }\n      return classNames.includes(lastCls.slice(1))\n    }\n    // check if selector (className) of specific css rule match target\n    return target instanceof RegExp\n      ? target.test(selector)\n      : selector.includes(target)\n  })\n}\n\nexport function getMediaRules(rules: Array<Object>, media: string): Array<any> {\n  return flatMap(\n    rules.filter((rule) => {\n      if (rule.type !== '@media') {\n        return false\n      }\n      return rule.value.replace(/\\s/g, '').includes(media.replace(/\\s/g, ''))\n    }),\n    (media) => media.children\n  )\n}\n\nexport function isPrimitive(test: any) {\n  return test !== Object(test)\n}\n\nexport function hasIntersection(left: any[], right: any[]) {\n  return left.some((value) => right.includes(value))\n}\n","// @flow\nimport prettify from '@emotion/css-prettifier'\nimport { replaceClassNames } from './replace-class-names'\nimport {\n  getClassNamesFromNodes,\n  isReactElement,\n  isEmotionCssPropElementType,\n  isEmotionCssPropEnzymeElement,\n  isDOMElement,\n  getStylesFromClassNames,\n  getStyleElements,\n  getKeys,\n  flatMap,\n  isPrimitive,\n  hasIntersection,\n} from './utils'\n\nfunction getNodes(node, nodes = []) {\n  if (Array.isArray(node)) {\n    for (let child of node) {\n      getNodes(child, nodes)\n    }\n    return nodes\n  }\n\n  if (typeof node === 'object') {\n    nodes.push(node)\n  }\n\n  if (node.children) {\n    for (let child of node.children) {\n      getNodes(child, nodes)\n    }\n  }\n\n  return nodes\n}\n\nfunction copyProps(target, source) {\n  return Object.defineProperties(\n    target,\n    Object.getOwnPropertyDescriptors(source)\n  )\n}\n\nfunction deepTransform(node, transform) {\n  if (Array.isArray(node)) {\n    return node.map((child) => deepTransform(child, transform))\n  }\n\n  const transformed: any = transform(node)\n\n  if (transformed !== node && transformed.children) {\n    return copyProps(transformed, {\n      // flatMap to allow a child of <A><B /><C /></A> to be transformed to <B /><C />\n      children: flatMap(\n        (deepTransform(transformed.children, transform): any),\n        (id) => id\n      ),\n    })\n  }\n\n  return transformed\n}\n\nfunction getPrettyStylesFromClassNames(\n  classNames: Array<string>,\n  elements: Array<HTMLStyleElement>,\n  indentation: string\n) {\n  return prettify(getStylesFromClassNames(classNames, elements), indentation)\n}\n\nexport type Options = {\n  classNameReplacer?: (className: string, index: number) => string,\n  DOMElements?: boolean,\n}\n\nfunction filterEmotionProps(props = {}) {\n  const {\n    css,\n    __EMOTION_TYPE_PLEASE_DO_NOT_USE__,\n    __EMOTION_LABEL_PLEASE_DO_NOT_USE__,\n    ...rest\n  } = props\n\n  rest.css = 'unknown styles'\n\n  return rest\n}\n\nfunction isShallowEnzymeElement(element: any, classNames: string[]) {\n  const delimiter = ' '\n  const childClassNames = flatMap(element.children || [], ({ props = {} }) =>\n    (props.className || '').split(delimiter)\n  ).filter(Boolean)\n  return !hasIntersection(classNames, childClassNames)\n}\n\nconst createConvertEmotionElements = (keys: string[], printer: *) => (\n  node: any\n) => {\n  if (isPrimitive(node)) {\n    return node\n  }\n  if (isEmotionCssPropEnzymeElement(node)) {\n    const cssClassNames = (node.props.css.name || '').split(' ')\n    const expectedClassNames = flatMap(cssClassNames, (cssClassName) =>\n      keys.map((key) => `${key}-${cssClassName}`)\n    )\n    // if this is a shallow element, we need to manufacture the className\n    // since the underlying component is not rendered.\n    if (isShallowEnzymeElement(node, expectedClassNames)) {\n      const className = [node.props.className]\n        .concat(expectedClassNames)\n        .filter(Boolean)\n        .join(' ')\n      const emotionType = node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__\n      // emotionType will be a string for DOM elements\n      const type =\n        typeof emotionType === 'string' ? emotionType : emotionType.name\n      return {\n        ...node,\n        props: filterEmotionProps({\n          ...node.props,\n          className,\n        }),\n        type,\n      }\n    } else {\n      return node.children\n    }\n  }\n  if (isEmotionCssPropElementType(node)) {\n    return {\n      ...node,\n      props: filterEmotionProps(node.props),\n      type: node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__,\n    }\n  }\n  if (isReactElement(node)) {\n    return copyProps({}, node)\n  }\n  return node\n}\n\nfunction clean(node: any, classNames: string[]) {\n  if (Array.isArray(node)) {\n    for (const child of node) {\n      clean(child, classNames)\n    }\n    return\n  }\n  if (node.children) {\n    for (const child of node.children) {\n      clean(child, classNames)\n    }\n  }\n  if (node.props) {\n    const { className } = node.props\n    if (!className) {\n      // if it's empty, remove it\n      delete node.props.className\n    } else {\n      const hasKnownClass = hasIntersection(className.split(' '), classNames)\n      if (hasKnownClass) {\n        delete node.props.css\n      }\n    }\n  }\n}\n\nexport function createSerializer({\n  classNameReplacer,\n  DOMElements = true,\n}: Options = {}) {\n  const cache = new WeakSet()\n  const isTransformed = (val) => cache.has(val)\n\n  function serialize(\n    val: *,\n    config: *,\n    indentation: string,\n    depth: number,\n    refs: *,\n    printer: Function\n  ) {\n    const elements = getStyleElements()\n    const keys = getKeys(elements)\n    const convertEmotionElements = createConvertEmotionElements(keys, printer)\n    const converted = deepTransform(val, convertEmotionElements)\n    const nodes = getNodes(converted)\n    const classNames = getClassNamesFromNodes(nodes)\n    const styles = getPrettyStylesFromClassNames(\n      classNames,\n      elements,\n      config.indent\n    )\n    clean(converted, classNames)\n\n    nodes.forEach(cache.add, cache)\n    const printedVal = printer(converted, config, indentation, depth, refs)\n    nodes.forEach(cache.delete, cache)\n\n    return replaceClassNames(\n      classNames,\n      styles,\n      printedVal,\n      keys,\n      classNameReplacer\n    )\n  }\n\n  return {\n    test(val: *) {\n      return (\n        val &&\n        !isTransformed(val) &&\n        (isReactElement(val) || (DOMElements && isDOMElement(val)))\n      )\n    },\n    serialize,\n  }\n}\n","// @flow\nimport chalk from 'chalk'\nimport * as stylis from 'stylis'\nimport * as specificity from 'specificity'\nimport {\n  getClassNamesFromNodes,\n  getStylesFromClassNames,\n  getStyleElements,\n  hasClassNames,\n  getMediaRules,\n  findLast,\n} from './utils'\n\n/*\n * Taken from\n * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L234\n */\nfunction isA(typeName, value) {\n  return Object.prototype.toString.apply(value) === `[object ${typeName}]`\n}\n\n/*\n * Taken from\n * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L36\n */\nfunction isAsymmetric(obj) {\n  return obj && isA('Function', obj.asymmetricMatch)\n}\n\nfunction valueMatches(declaration, value) {\n  if (value instanceof RegExp) {\n    return value.test(declaration.children)\n  }\n\n  if (isAsymmetric(value)) {\n    return value.asymmetricMatch(declaration.children)\n  }\n\n  return value === declaration.children\n}\n\nfunction toHaveStyleRule(\n  received: *,\n  property: *,\n  value: *,\n  options?: { target?: string, media?: string } = {}\n) {\n  const { target, media } = options\n  const classNames = getClassNamesFromNodes([received])\n  const cssString = getStylesFromClassNames(classNames, getStyleElements())\n  let preparedRules = stylis.compile(cssString)\n  if (media) {\n    preparedRules = getMediaRules(preparedRules, media)\n  }\n  const result = preparedRules\n    .filter(\n      (rule) =>\n        rule.type === 'rule' && hasClassNames(classNames, rule.props, target)\n    )\n    .reduce((acc, rule) => {\n      const lastMatchingDeclaration = findLast(\n        rule.children,\n        (dec) => dec.type === 'decl' && dec.props === property\n      )\n      if (!lastMatchingDeclaration) {\n        return acc\n      }\n      return acc.concat(\n        rule.props.map((selector) => ({\n          selector,\n          declaration: lastMatchingDeclaration,\n        }))\n      )\n    }, [])\n    .sort(({ selector: selectorA }, { selector: selectorB }) =>\n      specificity.compare(selectorA, selectorB)\n    )\n    .pop()\n\n  if (!result) {\n    return {\n      pass: false,\n      message: () => `Property not found: ${property}`,\n    }\n  }\n\n  const { declaration } = result\n  const pass = valueMatches(declaration, value)\n\n  const message = () =>\n    `Expected ${property}${pass ? ' not ' : ' '}to match:\\n` +\n    `  ${chalk.green(value)}\\n` +\n    'Received:\\n' +\n    `  ${chalk.red(declaration.children)}`\n\n  return {\n    pass,\n    message,\n  }\n}\n\nexport let matchers = { toHaveStyleRule }\n"],"names":["defaultClassNameReplacer","className","index","componentSelectorClassNamePattern","isBrowser","document","flatMap","arr","iteratee","concat","map","getClassNames","selectors","classes","split","isTagWithClassName","node","prop","type","isReactElement","val","$$typeof","Symbol","for","domElementPattern","getClassNamesFromNodes","nodes","reduce","findWhere","getClassNameProp","found","length","first","findNodeWithClassName","dive","shouldDive","getClassNamesFromEnzyme","cheerio","attr","getClassNamesFromCheerio","props","class","getClassNamesFromTestRenderer","getAttribute","getClassNamesFromDOMElement","keyframesPattern","removeCommentPattern","getElementRules","element","nonSpeedyRule","textContent","sheet","slice","call","cssRules","cssRule","cssText","getStylesFromClassNames","classNames","elements","keys","getKeys","targetClassName","find","test","keyPattern","join","classNamesRegExp","RegExp","filteredClassNames","filter","selectorPattern","cls","rules","styles","rule","match","fromIndex","predicate","i","findIndexFrom","Boolean","sort","ruleA","classNameIndexA","ruleB","classNameIndexB","keyframesMap","keyframes","name","undefined","getKeyframesMap","keyframeNameKeys","Object","keyframesStyles","keyframesNamePattern","keyframesNameCache","replace","value","getStyleElements","Error","Array","from","querySelectorAll","Set","hasIntersection","left","right","some","includes","getNodes","isArray","child","push","children","copyProps","target","source","defineProperties","getOwnPropertyDescriptors","deepTransform","transform","transformed","id","filterEmotionProps","rest","css","clean","createSerializer","classNameReplacer","DOMElements","cache","WeakSet","has","isTransformed","nodeType","constructor","isDOMElement","serialize","config","indentation","depth","refs","printer","converted","expectedClassNames","cssClassName","key","emotionType","__EMOTION_TYPE_PLEASE_DO_NOT_USE__","displayName","isEmotionCssPropElementType","createConvertEmotionElements","prettify","getPrettyStylesFromClassNames","indent","forEach","add","printedVal","delete","code","acc","escapedRegex","replaceClassNames","matchers","toHaveStyleRule","received","property","options","media","cssString","preparedRules","stylis","getMediaRules","result","selector","lastCls","hasClassNames","lastMatchingDeclaration","dec","findLast","declaration","selectorA","selectorB","specificity","pop","pass","message","obj","prototype","toString","apply","asymmetricMatch","valueMatches","chalk","green","red"],"mappings":"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"}