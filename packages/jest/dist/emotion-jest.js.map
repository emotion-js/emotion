{"version":3,"file":"emotion-jest.js","sources":["../src/replace-class-names.js","../src/utils.js","../src/create-serializer.js","../src/matchers.js"],"sourcesContent":["// @flow\nfunction defaultClassNameReplacer(className, index) {\n  return `emotion-${index}`\n}\n\nconst componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/\n\nexport const replaceClassNames = (\n  classNames: Array<string>,\n  styles: string,\n  code: string,\n  keys: Array<string>,\n  classNameReplacer: (\n    className: string,\n    index: number\n  ) => string = defaultClassNameReplacer\n) => {\n  let index = 0\n  let keyPattern = new RegExp(`^(${keys.join('|')})-`)\n\n  return classNames.reduce((acc, className) => {\n    if (\n      keyPattern.test(className) ||\n      componentSelectorClassNamePattern.test(className)\n    ) {\n      const escapedRegex = new RegExp(\n        className.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&'),\n        'g'\n      )\n      return acc.replace(escapedRegex, classNameReplacer(className, index++))\n    }\n    return acc\n  }, `${styles}${styles ? '\\n\\n' : ''}${code}`)\n}\n","// @flow\n\nconst isBrowser = typeof document !== 'undefined'\n\nfunction last(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined\n}\n\nexport function flatMap<T, S>(arr: T[], iteratee: (arg: T) => S[] | S): S[] {\n  return [].concat(...arr.map(iteratee))\n}\n\nexport function findLast<T>(arr: T[], predicate: (T) => boolean) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i]\n    }\n  }\n}\n\nexport function findIndexFrom<T>(\n  arr: T[],\n  fromIndex: number,\n  predicate: (T) => boolean\n) {\n  for (let i = fromIndex; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nfunction getClassNames(selectors: any, classes?: string) {\n  return classes ? selectors.concat(classes.split(' ')) : selectors\n}\n\nfunction getClassNamesFromTestRenderer(selectors, { props = {} }) {\n  return getClassNames(selectors, props.className || props.class)\n}\n\nfunction shouldDive(node) {\n  return typeof node.dive === 'function' && typeof node.type() !== 'string'\n}\n\nfunction isTagWithClassName(node) {\n  return node.prop('className') && typeof node.type() === 'string'\n}\n\nfunction findNodeWithClassName(node) {\n  // Find the first node with a className prop\n  const found = node.findWhere(isTagWithClassName)\n  return found.length ? found.first() : null\n}\n\nfunction getClassNameProp(node) {\n  return (node && node.prop('className')) || ''\n}\n\nfunction getClassNamesFromEnzyme(selectors, node) {\n  // We need to dive in to get the className if we have a styled element from a shallow render\n  const isShallow = shouldDive(node)\n  const nodeWithClassName = findNodeWithClassName(\n    isShallow ? node.dive() : node\n  )\n  return getClassNames(selectors, getClassNameProp(nodeWithClassName))\n}\n\nfunction getClassNamesFromCheerio(selectors, node) {\n  const classes = node.attr('class')\n  return getClassNames(selectors, classes)\n}\n\nfunction getClassNamesFromDOMElement(selectors, node: any) {\n  return getClassNames(selectors, node.getAttribute('class'))\n}\n\nexport function isReactElement(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.test.json') ||\n    val.$$typeof === Symbol.for('react.element')\n  )\n}\n\nexport function isEmotionCssPropElementType(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.element') &&\n    val.type.$$typeof === Symbol.for('react.forward_ref') &&\n    val.type.displayName === 'EmotionCssPropInternal'\n  )\n}\n\nexport function isEmotionCssPropEnzymeElement(val: any): boolean {\n  return (\n    val.$$typeof === Symbol.for('react.test.json') &&\n    val.type === 'EmotionCssPropInternal'\n  )\n}\nconst domElementPattern = /^((HTML|SVG)\\w*)?Element$/\n\nexport function isDOMElement(val: any): boolean {\n  return (\n    val.nodeType === 1 &&\n    val.constructor &&\n    val.constructor.name &&\n    domElementPattern.test(val.constructor.name)\n  )\n}\n\nfunction isEnzymeElement(val: any): boolean {\n  return typeof val.findWhere === 'function'\n}\n\nfunction isCheerioElement(val: any): boolean {\n  return val.cheerio === '[cheerio object]'\n}\n\nexport function getClassNamesFromNodes(nodes: Array<any>) {\n  return nodes.reduce((selectors, node) => {\n    if (isEnzymeElement(node)) {\n      return getClassNamesFromEnzyme(selectors, node)\n    } else if (isCheerioElement(node)) {\n      return getClassNamesFromCheerio(selectors, node)\n    } else if (isReactElement(node)) {\n      return getClassNamesFromTestRenderer(selectors, node)\n    }\n    return getClassNamesFromDOMElement(selectors, node)\n  }, [])\n}\n\nconst keyframesPattern = /^@keyframes\\s+(animation-[^{\\s]+)+/\n\nconst removeCommentPattern = /\\/\\*[\\s\\S]*?\\*\\//g\n\nconst getElementRules = (element: HTMLStyleElement): string[] => {\n  const nonSpeedyRule = element.textContent\n  if (nonSpeedyRule) {\n    return [nonSpeedyRule]\n  }\n  if (!element.sheet) {\n    return []\n  }\n  // $FlowFixMe - flow doesn't know about `cssRules` property\n  return [].slice.call(element.sheet.cssRules).map((cssRule) => cssRule.cssText)\n}\n\nconst getKeyframesMap = (rules) =>\n  rules.reduce((keyframes, rule) => {\n    const match = rule.match(keyframesPattern)\n    if (match !== null) {\n      const name = match[1]\n      if (keyframes[name] === undefined) {\n        keyframes[name] = ''\n      }\n      keyframes[name] += rule\n    }\n    return keyframes\n  }, {})\n\nexport function getStylesFromClassNames(\n  classNames: Array<string>,\n  elements: Array<HTMLStyleElement>\n): string {\n  if (!classNames.length) {\n    return ''\n  }\n  const keys = getKeys(elements)\n  if (!keys.length) {\n    return ''\n  }\n\n  const targetClassName = classNames.find((className) =>\n    /^e[a-z0-9]+$/.test(className)\n  )\n  const keyPattern = `(${keys.join('|')})-`\n  const classNamesRegExp = new RegExp(\n    targetClassName ? `^(${keyPattern}|${targetClassName})` : `^${keyPattern}`\n  )\n  const filteredClassNames = classNames.filter((className) =>\n    classNamesRegExp.test(className)\n  )\n\n  if (!filteredClassNames.length) {\n    return ''\n  }\n  const selectorPattern = new RegExp(\n    '\\\\.(?:' + filteredClassNames.map((cls) => `(${cls})`).join('|') + ')'\n  )\n\n  const rules = flatMap(elements, getElementRules)\n\n  let styles = rules\n    .map((rule: string) => {\n      const match = rule.match(selectorPattern)\n      if (!match) {\n        return null\n      }\n      // `selectorPattern` represents all emotion-generated class names\n      // each possible class name is wrapped in a capturing group\n      // and those groups appear in the same order as they appear in the DOM within class attributes\n      // because we've gathered them from the DOM in such order\n      // given that information we can sort matched rules based on the capturing group that has been matched\n      // to end up with styles in a stable order\n      const matchedCapturingGroupIndex = findIndexFrom(match, 1, Boolean)\n      return [rule, matchedCapturingGroupIndex]\n    })\n    .filter(Boolean)\n    .sort(\n      ([ruleA, classNameIndexA], [ruleB, classNameIndexB]) =>\n        classNameIndexA - classNameIndexB\n    )\n    .map(([rule]) => rule)\n    .join('')\n\n  const keyframesMap = getKeyframesMap(rules)\n  const keyframeNameKeys = Object.keys(keyframesMap)\n  let keyframesStyles = ''\n\n  if (keyframeNameKeys.length) {\n    const keyframesNamePattern = new RegExp(keyframeNameKeys.join('|'), 'g')\n    const keyframesNameCache = {}\n    let index = 0\n\n    styles = styles.replace(keyframesNamePattern, (name) => {\n      if (keyframesNameCache[name] === undefined) {\n        keyframesNameCache[name] = `animation-${index++}`\n        keyframesStyles += keyframesMap[name]\n      }\n      return keyframesNameCache[name]\n    })\n\n    keyframesStyles = keyframesStyles.replace(keyframesNamePattern, (value) => {\n      return keyframesNameCache[value]\n    })\n  }\n\n  return (keyframesStyles + styles).replace(removeCommentPattern, '')\n}\n\nexport function getStyleElements(): Array<HTMLStyleElement> {\n  if (!isBrowser) {\n    throw new Error(\n      'jest-emotion requires jsdom. See https://jestjs.io/docs/en/configuration#testenvironment-string for more information.'\n    )\n  }\n  const elements = Array.from(document.querySelectorAll('style[data-emotion]'))\n  // $FlowFixMe\n  return elements\n}\n\nconst unique = (arr) => Array.from(new Set(arr))\n\nexport function getKeys(elements: Array<HTMLStyleElement>) {\n  const keys = unique(\n    elements.map(\n      (element) =>\n        // $FlowFixMe we know it exists since we query for elements with this attribute\n        (element.getAttribute('data-emotion'): string)\n    )\n  ).filter(Boolean)\n  return keys\n}\n\nexport function hasClassNames(\n  classNames: Array<string>,\n  selectors: Array<string>,\n  target?: string | RegExp\n): boolean {\n  // selectors is the classNames of specific css rule\n  return selectors.some((selector) => {\n    // if no target, use className of the specific css rule and try to find it\n    // in the list of received node classNames to make sure this css rule\n    // applied for root element\n    if (!target) {\n      const lastCls = last(selector.split(' '))\n      if (!lastCls) {\n        return false\n      }\n      return classNames.includes(lastCls.slice(1))\n    }\n    // check if selector (className) of specific css rule match target\n    return target instanceof RegExp\n      ? target.test(selector)\n      : selector.includes(target)\n  })\n}\n\nexport function getMediaRules(rules: Array<Object>, media: string): Array<any> {\n  return flatMap(\n    rules.filter((rule) => {\n      if (rule.type !== '@media') {\n        return false\n      }\n      return rule.value.replace(/\\s/g, '').includes(media.replace(/\\s/g, ''))\n    }),\n    (media) => media.children\n  )\n}\n\nexport function isPrimitive(test: any) {\n  return test !== Object(test)\n}\n\nexport function hasIntersection(left: any[], right: any[]) {\n  return left.some((value) => right.includes(value))\n}\n","// @flow\nimport prettify from '@emotion/css-prettifier'\nimport { replaceClassNames } from './replace-class-names'\nimport {\n  getClassNamesFromNodes,\n  isReactElement,\n  isEmotionCssPropElementType,\n  isEmotionCssPropEnzymeElement,\n  isDOMElement,\n  getStylesFromClassNames,\n  getStyleElements,\n  getKeys,\n  flatMap,\n  isPrimitive,\n  hasIntersection,\n} from './utils'\n\nfunction getNodes(node, nodes = []) {\n  if (Array.isArray(node)) {\n    for (let child of node) {\n      getNodes(child, nodes)\n    }\n    return nodes\n  }\n\n  if (typeof node === 'object') {\n    nodes.push(node)\n  }\n\n  if (node.children) {\n    for (let child of node.children) {\n      getNodes(child, nodes)\n    }\n  }\n\n  return nodes\n}\n\nfunction copyProps(target, source) {\n  return Object.defineProperties(\n    target,\n    Object.getOwnPropertyDescriptors(source)\n  )\n}\n\nfunction deepTransform(node, transform) {\n  if (Array.isArray(node)) {\n    return node.map((child) => deepTransform(child, transform))\n  }\n\n  const transformed: any = transform(node)\n\n  if (transformed !== node && transformed.children) {\n    return copyProps(transformed, {\n      // flatMap to allow a child of <A><B /><C /></A> to be transformed to <B /><C />\n      children: flatMap(\n        (deepTransform(transformed.children, transform): any),\n        (id) => id\n      ),\n    })\n  }\n\n  return transformed\n}\n\nfunction getPrettyStylesFromClassNames(\n  classNames: Array<string>,\n  elements: Array<HTMLStyleElement>,\n  indentation: string\n) {\n  return prettify(getStylesFromClassNames(classNames, elements), indentation)\n}\n\nexport type Options = {\n  classNameReplacer?: (className: string, index: number) => string,\n  DOMElements?: boolean,\n}\n\nfunction filterEmotionProps(props = {}) {\n  const {\n    css,\n    __EMOTION_TYPE_PLEASE_DO_NOT_USE__,\n    __EMOTION_LABEL_PLEASE_DO_NOT_USE__,\n    ...rest\n  } = props\n\n  rest.css = 'unknown styles'\n\n  return rest\n}\n\nfunction isShallowEnzymeElement(element: any, classNames: string[]) {\n  const delimiter = ' '\n  const childClassNames = flatMap(element.children || [], ({ props = {} }) =>\n    (props.className || '').split(delimiter)\n  ).filter(Boolean)\n  return !hasIntersection(classNames, childClassNames)\n}\n\nconst createConvertEmotionElements = (keys: string[], printer: *) => (\n  node: any\n) => {\n  if (isPrimitive(node)) {\n    return node\n  }\n  if (isEmotionCssPropEnzymeElement(node)) {\n    const cssClassNames = (node.props.css.name || '').split(' ')\n    const expectedClassNames = flatMap(cssClassNames, (cssClassName) =>\n      keys.map((key) => `${key}-${cssClassName}`)\n    )\n    // if this is a shallow element, we need to manufacture the className\n    // since the underlying component is not rendered.\n    if (isShallowEnzymeElement(node, expectedClassNames)) {\n      const className = [node.props.className]\n        .concat(expectedClassNames)\n        .filter(Boolean)\n        .join(' ')\n      const emotionType = node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__\n      // emotionType will be a string for DOM elements\n      const type =\n        typeof emotionType === 'string' ? emotionType : emotionType.name\n      return {\n        ...node,\n        props: filterEmotionProps({\n          ...node.props,\n          className,\n        }),\n        type,\n      }\n    } else {\n      return node.children\n    }\n  }\n  if (isEmotionCssPropElementType(node)) {\n    return {\n      ...node,\n      props: filterEmotionProps(node.props),\n      type: node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__,\n    }\n  }\n  if (isReactElement(node)) {\n    return copyProps({}, node)\n  }\n  return node\n}\n\nfunction clean(node: any, classNames: string[]) {\n  if (Array.isArray(node)) {\n    for (const child of node) {\n      clean(child, classNames)\n    }\n    return\n  }\n  if (node.children) {\n    for (const child of node.children) {\n      clean(child, classNames)\n    }\n  }\n  if (node.props) {\n    const { className } = node.props\n    if (!className) {\n      // if it's empty, remove it\n      delete node.props.className\n    } else {\n      const hasKnownClass = hasIntersection(className.split(' '), classNames)\n      if (hasKnownClass) {\n        delete node.props.css\n      }\n    }\n  }\n}\n\nexport function createSerializer({\n  classNameReplacer,\n  DOMElements = true,\n}: Options = {}) {\n  const cache = new WeakSet()\n  const isTransformed = (val) => cache.has(val)\n\n  function serialize(\n    val: *,\n    config: *,\n    indentation: string,\n    depth: number,\n    refs: *,\n    printer: Function\n  ) {\n    const elements = getStyleElements()\n    const keys = getKeys(elements)\n    const convertEmotionElements = createConvertEmotionElements(keys, printer)\n    const converted = deepTransform(val, convertEmotionElements)\n    const nodes = getNodes(converted)\n    const classNames = getClassNamesFromNodes(nodes)\n    const styles = getPrettyStylesFromClassNames(\n      classNames,\n      elements,\n      config.indent\n    )\n    clean(converted, classNames)\n\n    nodes.forEach(cache.add, cache)\n    const printedVal = printer(converted, config, indentation, depth, refs)\n    nodes.forEach(cache.delete, cache)\n\n    return replaceClassNames(\n      classNames,\n      styles,\n      printedVal,\n      keys,\n      classNameReplacer\n    )\n  }\n\n  return {\n    test(val: *) {\n      return (\n        val &&\n        !isTransformed(val) &&\n        (isReactElement(val) || (DOMElements && isDOMElement(val)))\n      )\n    },\n    serialize,\n  }\n}\n","// @flow\nimport chalk from 'chalk'\nimport * as stylis from 'stylis'\nimport * as specificity from 'specificity'\nimport {\n  getClassNamesFromNodes,\n  getStylesFromClassNames,\n  getStyleElements,\n  hasClassNames,\n  getMediaRules,\n  findLast,\n} from './utils'\n\n/*\n * Taken from\n * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L234\n */\nfunction isA(typeName, value) {\n  return Object.prototype.toString.apply(value) === `[object ${typeName}]`\n}\n\n/*\n * Taken from\n * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L36\n */\nfunction isAsymmetric(obj) {\n  return obj && isA('Function', obj.asymmetricMatch)\n}\n\nfunction valueMatches(declaration, value) {\n  if (value instanceof RegExp) {\n    return value.test(declaration.children)\n  }\n\n  if (isAsymmetric(value)) {\n    return value.asymmetricMatch(declaration.children)\n  }\n\n  return value === declaration.children\n}\n\nfunction toHaveStyleRule(\n  received: *,\n  property: *,\n  value: *,\n  options?: { target?: string, media?: string } = {}\n) {\n  const { target, media } = options\n  const classNames = getClassNamesFromNodes([received])\n  const cssString = getStylesFromClassNames(classNames, getStyleElements())\n  let preparedRules = stylis.compile(cssString)\n  if (media) {\n    preparedRules = getMediaRules(preparedRules, media)\n  }\n  const result = preparedRules\n    .filter(\n      (rule) =>\n        rule.type === 'rule' && hasClassNames(classNames, rule.props, target)\n    )\n    .reduce((acc, rule) => {\n      const lastMatchingDeclaration = findLast(\n        rule.children,\n        (dec) => dec.type === 'decl' && dec.props === property\n      )\n      if (!lastMatchingDeclaration) {\n        return acc\n      }\n      return acc.concat(\n        rule.props.map((selector) => ({\n          selector,\n          declaration: lastMatchingDeclaration,\n        }))\n      )\n    }, [])\n    .sort(({ selector: selectorA }, { selector: selectorB }) =>\n      specificity.compare(selectorA, selectorB)\n    )\n    .pop()\n\n  if (!result) {\n    return {\n      pass: false,\n      message: () => `Property not found: ${property}`,\n    }\n  }\n\n  const { declaration } = result\n  const pass = valueMatches(declaration, value)\n\n  const message = () =>\n    `Expected ${property}${pass ? ' not ' : ' '}to match:\\n` +\n    `  ${chalk.green(value)}\\n` +\n    'Received:\\n' +\n    `  ${chalk.red(declaration.children)}`\n\n  return {\n    pass,\n    message,\n  }\n}\n\nexport let matchers = { toHaveStyleRule }\n"],"names":["defaultClassNameReplacer","className","index","componentSelectorClassNamePattern","isBrowser","document","flatMap","arr","iteratee","concat","map","getClassNames","selectors","classes","split","isTagWithClassName","node","prop","type","isReactElement","val","$$typeof","Symbol","domElementPattern","getClassNamesFromNodes","nodes","reduce","findWhere","getClassNameProp","found","length","first","findNodeWithClassName","dive","shouldDive","getClassNamesFromEnzyme","cheerio","attr","getClassNamesFromCheerio","props","getClassNamesFromTestRenderer","getAttribute","getClassNamesFromDOMElement","keyframesPattern","removeCommentPattern","getElementRules","element","nonSpeedyRule","textContent","sheet","slice","call","cssRules","cssRule","cssText","getStylesFromClassNames","classNames","elements","keys","getKeys","targetClassName","find","test","keyPattern","join","classNamesRegExp","RegExp","filteredClassNames","filter","selectorPattern","cls","rules","styles","rule","match","fromIndex","predicate","i","findIndexFrom","Boolean","sort","keyframesMap","keyframes","name","undefined","getKeyframesMap","keyframeNameKeys","Object","keyframesStyles","keyframesNamePattern","keyframesNameCache","replace","value","getStyleElements","Error","Array","from","querySelectorAll","Set","hasIntersection","left","right","some","includes","getNodes","isArray","push","children","copyProps","target","source","defineProperties","getOwnPropertyDescriptors","deepTransform","transform","child","transformed","id","filterEmotionProps","rest","css","clean","matchers","toHaveStyleRule","received","property","options","media","cssString","preparedRules","stylis","getMediaRules","result","selector","lastCls","hasClassNames","acc","lastMatchingDeclaration","dec","findLast","declaration","specificity","pop","pass","message","obj","prototype","toString","apply","asymmetricMatch","valueMatches","chalk","green","red","classNameReplacer","DOMElements","cache","WeakSet","has","isTransformed","nodeType","constructor","isDOMElement","serialize","config","indentation","depth","refs","printer","converted","expectedClassNames","cssClassName","key","emotionType","__EMOTION_TYPE_PLEASE_DO_NOT_USE__","displayName","isEmotionCssPropElementType","createConvertEmotionElements","prettify","getPrettyStylesFromClassNames","indent","forEach","add","printedVal","code","escapedRegex","replaceClassNames"],"mappings":"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"}